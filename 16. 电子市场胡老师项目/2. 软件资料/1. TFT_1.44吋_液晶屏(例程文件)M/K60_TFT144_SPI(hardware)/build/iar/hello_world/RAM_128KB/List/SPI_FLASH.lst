###############################################################################
#                                                                             #
#                                                       16/Aug/2015  08:45:41 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Ping\Desktop\K60_TFT144_SPI\src\drivers\SPI\SPI #
#                    _FLASH.c                                                 #
#    Command line =  C:\Users\Ping\Desktop\K60_TFT144_SPI\src\drivers\SPI\SPI #
#                    _FLASH.c -D IAR -D TWR_K60N512 -lCN                      #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\RAM_128KB\List\ -lB C:\Users\Ping\Desktop\K60_TFT144_ #
#                    SPI\build\iar\hello_world\RAM_128KB\List\ -o             #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\RAM_128KB\Obj\ --no_cse --no_unroll --no_inline       #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\projects\hello_world\ -I                 #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\common\ -I C:\Users\Ping\Desktop\K60_TFT #
#                    144_SPI\build\iar\hello_world\..\..\..\src\cpu\ -I       #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\cpu\headers\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\adc16\ -I                        #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\enet\ -I                         #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\pmc\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\rtc\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\lptmr\ -I                        #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\uart\ -I                         #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\mcg\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\wdog\ -I                         #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\platforms\ -I                            #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\ftm\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\SPI\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\OLED\ -I                         #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\..\..\src\drivers\TFT\ -I                          #
#                    C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\..\ -On --use_c++_inline                              #
#    List file    =  C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\RAM_128KB\List\SPI_FLASH.lst                          #
#    Object file  =  C:\Users\Ping\Desktop\K60_TFT144_SPI\build\iar\hello_wor #
#                    ld\RAM_128KB\Obj\SPI_FLASH.o                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Ping\Desktop\K60_TFT144_SPI\src\drivers\SPI\SPI_FLASH.c
      1          
      2          /*************************************************************************
      3          
      4          SPI驱动程序：W25X/Q32的驱动程序
      5          
      6          //4Kbytes为一个Sector
      7          //16个扇区为1个Block
      8          //W25X16
      9          //容量为2M字节,共有32个Block,512个Sector
     10          
     11          
     12          
     13          *************************************************************************/
     14          
     15          #include "SPI_FLASH.H"
     16          
     17          #include "uart.h"
     18          
     19          
     20          /*************************************************
     21          函数功能：硬件SPI口发送或者接收一个字节数据
     22          
     23          *************************************************/
     24          
     25          //SPIx 读写一个字节
     26          //TxData:要写入的字节
     27          //返回值:读取到的字节

   \                                 In section .text, align 2, keep-with-next
     28          unsigned char SPIx_ReadWriteByte(unsigned char TxData)
     29          {		
   \                     SPIx_ReadWriteByte:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     30          	
     31            unsigned char i;
     32            
     33            i= SPI_Master_WriteRead(SPI0,TxData,SPI_PCS4,SPI_PCS_ASSERTED);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2210             MOVS     R2,#+16
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       SPI_Master_WriteRead
   \   00000012   0x0005             MOVS     R5,R0
     34            
     35             return  i;
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     36          
     37          }
     38          
     39          
     40          //读取SPI_FLASH的状态寄存器
     41          //BIT7  6   5   4   3   2   1   0
     42          //SPR   RV  TB BP2 BP1 BP0 WEL BUSY
     43          //SPR:默认0,状态寄存器保护位,配合WP使用
     44          //TB,BP2,BP1,BP0:FLASH区域写保护设置
     45          //WEL:写使能锁定
     46          //BUSY:忙标记位(1,忙;0,空闲)
     47          //默认:0x00

   \                                 In section .text, align 2, keep-with-next
     48          unsigned char SPI_Flash_ReadSR(void)   
     49          {  
   \                     SPI_Flash_ReadSR:
   \   00000000   0xB510             PUSH     {R4,LR}
     50            
     51          	unsigned char byte=0;   
   \   00000002   0x2400             MOVS     R4,#+0
     52                  
     53          	SPI_FLASH_CS_LOW(); 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     54                  //使能器件   
     55          	SPIx_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
     56                  
     57          	byte=SPIx_ReadWriteByte(0Xff);             //读取一个字节
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000024   0x0004             MOVS     R4,R0
     58           
     59          	SPI_FLASH_CS_HIGH();                            //取消片选
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000036   0x6889             LDR      R1,[R1, #+8]
   \   00000038   0x6008             STR      R0,[R1, #+0]
     60                  
     61          	return byte;   
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     62          
     63          
     64          } 
     65          //写SPI_FLASH状态寄存器
     66          //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!

   \                                 In section .text, align 2, keep-with-next
     67          void SPI_FLASH_Write_SR(unsigned char sr)   
     68          { 
   \                     SPI_FLASH_Write_SR:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     69          
     70          
     71          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     72          	SPIx_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
     73          	SPIx_ReadWriteByte(sr);               //写入一个字节  
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       SPIx_ReadWriteByte
     74          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000036   0x6889             LDR      R1,[R1, #+8]
   \   00000038   0x6008             STR      R0,[R1, #+0]
     75          
     76          
     77          }   
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
     78          //SPI_FLASH写使能	
     79          //将WEL置位   

   \                                 In section .text, align 2, keep-with-next
     80          void SPI_FLASH_Write_Enable(void)   
     81          {
   \                     SPI_FLASH_Write_Enable:
   \   00000000   0xB580             PUSH     {R7,LR}
     82          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000012   0x6889             LDR      R1,[R1, #+8]
   \   00000014   0x6008             STR      R0,[R1, #+0]
     83              SPIx_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0x.... 0x....      BL       SPIx_ReadWriteByte
     84          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     85          } 
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
     86          //SPI_FLASH写禁止	
     87          //将WEL清零  

   \                                 In section .text, align 2, keep-with-next
     88          void SPI_FLASH_Write_Disable(void)   
     89          {  
   \                     SPI_FLASH_Write_Disable:
   \   00000000   0xB580             PUSH     {R7,LR}
     90          	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000012   0x6889             LDR      R1,[R1, #+8]
   \   00000014   0x6008             STR      R0,[R1, #+0]
     91              SPIx_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       SPIx_ReadWriteByte
     92          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     93          } 			    
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
     94          //读取芯片ID W25X16的ID:0XEF14

   \                                 In section .text, align 2, keep-with-next
     95          unsigned short int SPI_Flash_ReadID(void)
     96          {
   \                     SPI_Flash_ReadID:
   \   00000000   0xB510             PUSH     {R4,LR}
     97          	unsigned short int Temp = 0;	  
   \   00000002   0x2400             MOVS     R4,#+0
     98          	SPI_FLASH_CS_LOW();				    
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
     99          	SPIx_ReadWriteByte(0x90);//发送读取ID命令	    
   \   00000018   0x2090             MOVS     R0,#+144
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
    100          	SPIx_ReadWriteByte(0x00); 	    
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       SPIx_ReadWriteByte
    101          	SPIx_ReadWriteByte(0x00); 	    
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       SPIx_ReadWriteByte
    102          	SPIx_ReadWriteByte(0x00); 	 			   
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       SPIx_ReadWriteByte
    103          	Temp|=SPIx_ReadWriteByte(0x00)<<8;  
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000036   0xEA54 0x2000      ORRS     R0,R4,R0, LSL #+8
   \   0000003A   0x0004             MOVS     R4,R0
    104          	Temp|=SPIx_ReadWriteByte(0xFF);	 
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000042   0x4320             ORRS     R0,R0,R4
   \   00000044   0x0004             MOVS     R4,R0
    105          	SPI_FLASH_CS_HIGH();				    
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000056   0x6889             LDR      R1,[R1, #+8]
   \   00000058   0x6008             STR      R0,[R1, #+0]
    106          	return Temp;
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    107          } 
    108          

   \                                 In section .text, align 2, keep-with-next
    109          unsigned int  SPI_Flash_ReadDeviceID(void)  	    //读取FLASH ID
    110          
    111          {
   \                     SPI_Flash_ReadDeviceID:
   \   00000000   0xB510             PUSH     {R4,LR}
    112          	unsigned int Temp = 0;	  
   \   00000002   0x2400             MOVS     R4,#+0
    113          	SPI_FLASH_CS_LOW();				    
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0840             LSRS     R0,R0,#+1
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
    114          	SPIx_ReadWriteByte(0x9F);//发送读取ID命令	    
   \   00000018   0x209F             MOVS     R0,#+159
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
    115          	//SPIx_ReadWriteByte(0x00); 	    
    116          	//SPIx_ReadWriteByte(0x00); 	    
    117          	//SPIx_ReadWriteByte(0x00); 	 			   
    118          	Temp|=SPIx_ReadWriteByte(0xFF)<<16;  
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000024   0xEA54 0x4000      ORRS     R0,R4,R0, LSL #+16
   \   00000028   0x0004             MOVS     R4,R0
    119          	Temp|=SPIx_ReadWriteByte(0xFF)<<8;
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000030   0xEA54 0x2000      ORRS     R0,R4,R0, LSL #+8
   \   00000034   0x0004             MOVS     R4,R0
    120          	Temp|=SPIx_ReadWriteByte(0xFF);	 
   \   00000036   0x20FF             MOVS     R0,#+255
   \   00000038   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   0000003C   0x4320             ORRS     R0,R0,R4
   \   0000003E   0x0004             MOVS     R4,R0
    121          	SPI_FLASH_CS_HIGH();
   \   00000040   0x....             LDR.N    R0,??DataTable13
   \   00000042   0x6880             LDR      R0,[R0, #+8]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004A   0x....             LDR.N    R1,??DataTable13
   \   0000004C   0x6889             LDR      R1,[R1, #+8]
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    122          					    
    123          	return Temp;
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    124          } 
    125          
    126            		    
    127          //读取SPI FLASH  
    128          //在指定地址开始读取指定长度的数据
    129          //pBuffer:数据存储区
    130          //ReadAddr:开始读取的地址(24bit)
    131          //NumByteToRead:要读取的字节数(最大65535)

   \                                 In section .text, align 2, keep-with-next
    132          void SPI_Flash_Read(unsigned char* pBuffer,unsigned int ReadAddr,unsigned short int NumByteToRead)//读取SPI FLASH 在指定地址开始读取指定长度的数据   
    133          { 
   \                     SPI_Flash_Read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    134           	unsigned short int i;    												    
    135          	SPI_FLASH_CS_LOW();                            			//使能器件   
   \   00000008   0x....             LDR.N    R0,??DataTable13
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0840             LSRS     R0,R0,#+1
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable13
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x6008             STR      R0,[R1, #+0]
    136              SPIx_ReadWriteByte(W25X_ReadData);         				//发送读取命令   
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x.... 0x....      BL       SPIx_ReadWriteByte
    137              SPIx_ReadWriteByte((unsigned char)((ReadAddr)>>16));    //发送24bit地址    
   \   0000001E   0x0C28             LSRS     R0,R5,#+16
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       SPIx_ReadWriteByte
    138              SPIx_ReadWriteByte((unsigned char)((ReadAddr)>>8));   
   \   00000026   0x0A28             LSRS     R0,R5,#+8
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       SPIx_ReadWriteByte
    139              SPIx_ReadWriteByte((unsigned char)ReadAddr);   
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       SPIx_ReadWriteByte
    140              for(i=0;i<NumByteToRead;i++)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0007             MOVS     R7,R0
   \                     ??SPI_Flash_Read_0:
   \   0000003A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003E   0x42B7             CMP      R7,R6
   \   00000040   0xD206             BCS.N    ??SPI_Flash_Read_1
    141          	{ 
    142                  pBuffer[i]=SPIx_ReadWriteByte(0XFF);   				//循环读数  
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   00000048   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004A   0x5538             STRB     R0,[R7, R4]
    143              }
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0xE7F4             B.N      ??SPI_Flash_Read_0
    144          	SPI_FLASH_CS_HIGH();                            		//取消片选     	      
   \                     ??SPI_Flash_Read_1:
   \   00000050   0x....             LDR.N    R0,??DataTable13
   \   00000052   0x6880             LDR      R0,[R0, #+8]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005A   0x....             LDR.N    R1,??DataTable13
   \   0000005C   0x6889             LDR      R1,[R1, #+8]
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    145          }  
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    146          //SPI在一页(0~65535)内写入少于256个字节的数据
    147          //在指定地址开始写入最大256字节的数据
    148          //pBuffer:数据存储区
    149          //WriteAddr:开始写入的地址(24bit)
    150          //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 

   \                                 In section .text, align 2, keep-with-next
    151          void SPI_Flash_Write_Page(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)//SPI在一页(0~65535)内写入少于256个字节的数据
    152          {
   \                     SPI_Flash_Write_Page:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    153           	unsigned short int i;  
    154              SPI_FLASH_Write_Enable();                  					//SET WEL 
   \   00000008   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    155          	SPI_FLASH_CS_LOW();                            				//使能器件   
   \   0000000C   0x....             LDR.N    R0,??DataTable13
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0840             LSRS     R0,R0,#+1
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable13
   \   00000018   0x6889             LDR      R1,[R1, #+8]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    156              SPIx_ReadWriteByte(W25X_PageProgram);      					//发送写页命令   
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       SPIx_ReadWriteByte
    157              SPIx_ReadWriteByte((unsigned char)((WriteAddr)>>16)); 		//发送24bit地址    
   \   00000022   0x0C28             LSRS     R0,R5,#+16
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       SPIx_ReadWriteByte
    158              SPIx_ReadWriteByte((unsigned char)((WriteAddr)>>8));   
   \   0000002A   0x0A28             LSRS     R0,R5,#+8
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       SPIx_ReadWriteByte
    159              SPIx_ReadWriteByte((unsigned char)WriteAddr);   
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       SPIx_ReadWriteByte
    160              for(i=0;i<NumByteToWrite;i++)SPIx_ReadWriteByte(pBuffer[i]);//循环写数  
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0007             MOVS     R7,R0
   \                     ??SPI_Flash_Write_Page_0:
   \   0000003E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000040   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000042   0x42B7             CMP      R7,R6
   \   00000044   0xD205             BCS.N    ??SPI_Flash_Write_Page_1
   \   00000046   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000048   0x5D38             LDRB     R0,[R7, R4]
   \   0000004A   0x.... 0x....      BL       SPIx_ReadWriteByte
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
   \   00000050   0xE7F5             B.N      ??SPI_Flash_Write_Page_0
    161          	SPI_FLASH_CS_HIGH();                            			//取消片选 
   \                     ??SPI_Flash_Write_Page_1:
   \   00000052   0x....             LDR.N    R0,??DataTable13
   \   00000054   0x6880             LDR      R0,[R0, #+8]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005C   0x....             LDR.N    R1,??DataTable13
   \   0000005E   0x6889             LDR      R1,[R1, #+8]
   \   00000060   0x6008             STR      R0,[R1, #+0]
    162          	SPI_Flash_Wait_Busy();					   					//等待写入结束
   \   00000062   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    163          } 
   \   00000066   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    164          //无检验写SPI FLASH 
    165          //必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!
    166          //具有自动换页功能 
    167          //在指定地址开始写入指定长度的数据,但是要确保地址不越界!
    168          //pBuffer:数据存储区
    169          //WriteAddr:开始写入的地址(24bit)
    170          //NumByteToWrite:要写入的字节数(最大65535)
    171          //CHECK OK

   \                                 In section .text, align 2, keep-with-next
    172          void SPI_Flash_Write_NoCheck(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)   
    173          { 			 		 
   \                     SPI_Flash_Write_NoCheck:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
    174          	unsigned short int pageremain;	   
    175          	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
   \   00000008   0xF44F 0x7080      MOV      R0,#+256
   \   0000000C   0xF44F 0x7180      MOV      R1,#+256
   \   00000010   0xFBB6 0xF2F1      UDIV     R2,R6,R1
   \   00000014   0xFB02 0x6211      MLS      R2,R2,R1,R6
   \   00000018   0x1A80             SUBS     R0,R0,R2
   \   0000001A   0x0004             MOVS     R4,R0
    176          	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000020   0x42BC             CMP      R4,R7
   \   00000022   0xD300             BCC.N    ??SPI_Flash_Write_NoCheck_0
   \   00000024   0x003C             MOVS     R4,R7
    177          	while(1)
    178          	{	   
    179          		SPI_Flash_Write_Page(pBuffer,WriteAddr,pageremain);
   \                     ??SPI_Flash_Write_NoCheck_0:
   \   00000026   0x0022             MOVS     R2,R4
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       SPI_Flash_Write_Page
    180          		if(NumByteToWrite==pageremain)break;//写入结束了
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x42A7             CMP      R7,R4
   \   00000038   0xD00F             BEQ.N    ??SPI_Flash_Write_NoCheck_1
    181          	 	else //NumByteToWrite>pageremain
    182          		{
    183          			pBuffer+=pageremain;
    184          			WriteAddr+=pageremain;	
    185          
    186          			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
    187          			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
    188          			else pageremain=NumByteToWrite; 	  //不够256个字节了
    189          		}
    190          	};	    
    191          } 
   \                     ??SPI_Flash_Write_NoCheck_2:
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0x1965             ADDS     R5,R4,R5
   \   0000003E   0xFA16 0xF684      UXTAH    R6,R6,R4
   \   00000042   0x1B3F             SUBS     R7,R7,R4
   \   00000044   0xF240 0x1001      MOVW     R0,#+257
   \   00000048   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004A   0x4287             CMP      R7,R0
   \   0000004C   0xD303             BCC.N    ??SPI_Flash_Write_NoCheck_3
   \   0000004E   0xF44F 0x7080      MOV      R0,#+256
   \   00000052   0x0004             MOVS     R4,R0
   \   00000054   0xE7E7             B.N      ??SPI_Flash_Write_NoCheck_0
   \                     ??SPI_Flash_Write_NoCheck_3:
   \   00000056   0x003C             MOVS     R4,R7
   \   00000058   0xE7E5             B.N      ??SPI_Flash_Write_NoCheck_0
   \                     ??SPI_Flash_Write_NoCheck_1:
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    192          //写SPI FLASH  
    193          //在指定地址开始写入指定长度的数据
    194          //该函数带擦除操作!
    195          //pBuffer:数据存储区
    196          //WriteAddr:开始写入的地址(24bit)
    197          //NumByteToWrite:要写入的字节数(最大65535)  		   
    198          

   \                                 In section .bss, align 4
    199          unsigned char SPI_FLASH_BUF[4096];
   \                     SPI_FLASH_BUF:
   \   00000000                      DS8 4096
    200          

   \                                 In section .text, align 2, keep-with-next
    201          void SPI_Flash_Write(unsigned char* pBuffer,unsigned int WriteAddr,unsigned short int NumByteToWrite)   
    202          { 
   \                     SPI_Flash_Write:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    203          	unsigned int secpos;
    204          	unsigned short int secoff;
    205          	unsigned short int secremain;	   
    206           	unsigned short int i;    
    207          	
    208          
    209          
    210          	secpos=WriteAddr/4096;//扇区地址 0~511 for w25x16
   \   0000000A   0x0B28             LSRS     R0,R5,#+12
   \   0000000C   0x0007             MOVS     R7,R0
    211          	secoff=WriteAddr%4096;//在扇区内的偏移
   \   0000000E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000012   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   00000016   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   0000001A   0x4688             MOV      R8,R1
    212          	secremain=4096-secoff;//扇区剩余空间大小   
   \   0000001C   0xF5D8 0x5080      RSBS     R0,R8,#+4096
   \   00000020   0x4681             MOV      R9,R0
    213          
    214          	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
   \   00000022   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x45B1             CMP      R9,R6
   \   0000002A   0xD300             BCC.N    ??SPI_Flash_Write_0
   \   0000002C   0x46B1             MOV      R9,R6
    215          	while(1) 
    216          	{	
    217          		SPI_Flash_Read(SPI_FLASH_BUF,secpos*4096,4096);//读出整个扇区的内容
   \                     ??SPI_Flash_Write_0:
   \   0000002E   0xF44F 0x5280      MOV      R2,#+4096
   \   00000032   0xF44F 0x5080      MOV      R0,#+4096
   \   00000036   0xFB00 0xF107      MUL      R1,R0,R7
   \   0000003A   0x....             LDR.N    R0,??DataTable13_1
   \   0000003C   0x.... 0x....      BL       SPI_Flash_Read
    218          		for(i=0;i<secremain;i++)//校验数据
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4682             MOV      R10,R0
   \                     ??SPI_Flash_Write_1:
   \   00000044   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000048   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000004C   0x45CA             CMP      R10,R9
   \   0000004E   0xD20A             BCS.N    ??SPI_Flash_Write_2
    219          		{
    220          			if(SPI_FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
   \   00000050   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000054   0xFA1A 0xF088      UXTAH    R0,R10,R8
   \   00000058   0x....             LDR.N    R1,??DataTable13_1
   \   0000005A   0x5C40             LDRB     R0,[R0, R1]
   \   0000005C   0x28FF             CMP      R0,#+255
   \   0000005E   0xD102             BNE.N    ??SPI_Flash_Write_2
    221          		}
   \                     ??SPI_Flash_Write_3:
   \   00000060   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000064   0xE7EE             B.N      ??SPI_Flash_Write_1
    222          		if(i<secremain)//需要擦除
   \                     ??SPI_Flash_Write_2:
   \   00000066   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000006A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000006E   0x45CA             CMP      R10,R9
   \   00000070   0xD221             BCS.N    ??SPI_Flash_Write_4
    223          		{
    224          			SPI_Flash_Erase_Sector(secpos);//擦除这个扇区
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0x.... 0x....      BL       SPI_Flash_Erase_Sector
    225          			for(i=0;i<secremain;i++)	   //复制
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4682             MOV      R10,R0
   \                     ??SPI_Flash_Write_5:
   \   0000007C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000080   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000084   0x45CA             CMP      R10,R9
   \   00000086   0xD20C             BCS.N    ??SPI_Flash_Write_6
    226          			{
    227          				SPI_FLASH_BUF[i+secoff]=pBuffer[i];	  
   \   00000088   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000008C   0xFA18 0xF08A      UXTAH    R0,R8,R10
   \   00000090   0x....             LDR.N    R1,??DataTable13_1
   \   00000092   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000096   0xF81A 0x2004      LDRB     R2,[R10, R4]
   \   0000009A   0x5442             STRB     R2,[R0, R1]
    228          			}
   \   0000009C   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000A0   0xE7EC             B.N      ??SPI_Flash_Write_5
    229          			SPI_Flash_Write_NoCheck(SPI_FLASH_BUF,secpos*4096,4096);//写入整个扇区  
   \                     ??SPI_Flash_Write_6:
   \   000000A2   0xF44F 0x5280      MOV      R2,#+4096
   \   000000A6   0xF44F 0x5080      MOV      R0,#+4096
   \   000000AA   0xFB00 0xF107      MUL      R1,R0,R7
   \   000000AE   0x....             LDR.N    R0,??DataTable13_1
   \   000000B0   0x.... 0x....      BL       SPI_Flash_Write_NoCheck
   \   000000B4   0xE005             B.N      ??SPI_Flash_Write_7
    230          
    231          		}else SPI_Flash_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
   \                     ??SPI_Flash_Write_4:
   \   000000B6   0x464A             MOV      R2,R9
   \   000000B8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000BA   0x0029             MOVS     R1,R5
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       SPI_Flash_Write_NoCheck
    232          		if(NumByteToWrite==secremain)break;//写入结束了
   \                     ??SPI_Flash_Write_7:
   \   000000C2   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C4   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000C8   0x454E             CMP      R6,R9
   \   000000CA   0xD015             BEQ.N    ??SPI_Flash_Write_8
    233          		else//写入未结束
    234          		{
    235          			secpos++;//扇区地址增1
    236          			secoff=0;//偏移位置为0 	 
    237          
    238          		   	pBuffer+=secremain;  //指针偏移
    239          			WriteAddr+=secremain;//写地址偏移	   
    240          		   	NumByteToWrite-=secremain;				//字节数递减
    241          			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
    242          			else secremain=NumByteToWrite;			//下一个扇区可以写完了
    243          		}	 
    244          	};	 	 
    245          }
   \                     ??SPI_Flash_Write_9:
   \   000000CC   0x1C7F             ADDS     R7,R7,#+1
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x4680             MOV      R8,R0
   \   000000D2   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000D6   0xEB19 0x0404      ADDS     R4,R9,R4
   \   000000DA   0xFA15 0xF589      UXTAH    R5,R5,R9
   \   000000DE   0xEBB6 0x0609      SUBS     R6,R6,R9
   \   000000E2   0xF241 0x0001      MOVW     R0,#+4097
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0x4286             CMP      R6,R0
   \   000000EA   0xD303             BCC.N    ??SPI_Flash_Write_10
   \   000000EC   0xF44F 0x5080      MOV      R0,#+4096
   \   000000F0   0x4681             MOV      R9,R0
   \   000000F2   0xE79C             B.N      ??SPI_Flash_Write_0
   \                     ??SPI_Flash_Write_10:
   \   000000F4   0x46B1             MOV      R9,R6
   \   000000F6   0xE79A             B.N      ??SPI_Flash_Write_0
   \                     ??SPI_Flash_Write_8:
   \   000000F8   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    246          //擦除整个芯片
    247          //整片擦除时间:
    248          //W25X16:25s 
    249          //W25X32:40s 
    250          //W25X64:40s 
    251          //等待时间超长...

   \                                 In section .text, align 2, keep-with-next
    252          void SPI_Flash_Erase_Chip(void)   
    253          {                                             
   \                     SPI_Flash_Erase_Chip:
   \   00000000   0xB580             PUSH     {R7,LR}
    254              SPI_FLASH_Write_Enable();                  //SET WEL 
   \   00000002   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    255              SPI_Flash_Wait_Busy();   
   \   00000006   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    256            	SPI_FLASH_CS_LOW();                        //使能器件   
   \   0000000A   0x....             LDR.N    R0,??DataTable13
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0840             LSRS     R0,R0,#+1
   \   00000012   0x0040             LSLS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable13
   \   00000016   0x6889             LDR      R1,[R1, #+8]
   \   00000018   0x6008             STR      R0,[R1, #+0]
    257              SPIx_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
   \   0000001A   0x20C7             MOVS     R0,#+199
   \   0000001C   0x.... 0x....      BL       SPIx_ReadWriteByte
    258          	SPI_FLASH_CS_HIGH();                       //取消片选     	      
   \   00000020   0x....             LDR.N    R0,??DataTable13
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x....             LDR.N    R1,??DataTable13
   \   0000002C   0x6889             LDR      R1,[R1, #+8]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    259          	SPI_Flash_Wait_Busy();   				   //等待芯片擦除结束
   \   00000030   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    260          }   
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    261          //擦除一个扇区
    262          //Dst_Addr:扇区地址 0~511 for w25x16
    263          //擦除一个扇区的最少时间:150ms

   \                                 In section .text, align 2, keep-with-next
    264          void SPI_Flash_Erase_Sector(unsigned int Dst_Addr)   
    265          {   
   \                     SPI_Flash_Erase_Sector:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266          	Dst_Addr*=4096;
   \   00000004   0xF44F 0x5080      MOV      R0,#+4096
   \   00000008   0x4344             MULS     R4,R0,R4
    267              SPI_FLASH_Write_Enable();                  //SET WEL 	 
   \   0000000A   0x.... 0x....      BL       SPI_FLASH_Write_Enable
    268              SPI_Flash_Wait_Busy();   
   \   0000000E   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    269            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000012   0x....             LDR.N    R0,??DataTable13
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0840             LSRS     R0,R0,#+1
   \   0000001A   0x0040             LSLS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R1,??DataTable13
   \   0000001E   0x6889             LDR      R1,[R1, #+8]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    270              SPIx_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x.... 0x....      BL       SPIx_ReadWriteByte
    271              SPIx_ReadWriteByte((unsigned char)((Dst_Addr)>>16));  //发送24bit地址    
   \   00000028   0x0C20             LSRS     R0,R4,#+16
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       SPIx_ReadWriteByte
    272              SPIx_ReadWriteByte((unsigned char)((Dst_Addr)>>8));   
   \   00000030   0x0A20             LSRS     R0,R4,#+8
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       SPIx_ReadWriteByte
    273              SPIx_ReadWriteByte((unsigned char)Dst_Addr);  
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       SPIx_ReadWriteByte
    274          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000040   0x....             LDR.N    R0,??DataTable13
   \   00000042   0x6880             LDR      R0,[R0, #+8]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000004A   0x....             LDR.N    R1,??DataTable13
   \   0000004C   0x6889             LDR      R1,[R1, #+8]
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    275              SPI_Flash_Wait_Busy();   				   //等待擦除完成
   \   00000050   0x.... 0x....      BL       SPI_Flash_Wait_Busy
    276          }  
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    277          //等待空闲

   \                                 In section .text, align 2, keep-with-next
    278          void SPI_Flash_Wait_Busy(void)   
    279          {   
   \                     SPI_Flash_Wait_Busy:
   \   00000000   0xB580             PUSH     {R7,LR}
    280          	
    281          	while ((SPI_Flash_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
   \                     ??SPI_Flash_Wait_Busy_0:
   \   00000002   0x.... 0x....      BL       SPI_Flash_ReadSR
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD4FB             BMI.N    ??SPI_Flash_Wait_Busy_0
    282          
    283          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    284          
    285            
    286          //进入掉电模式

   \                                 In section .text, align 2, keep-with-next
    287          void SPI_Flash_PowerDown(void)   
    288          { 
   \                     SPI_Flash_PowerDown:
   \   00000000   0xB580             PUSH     {R7,LR}
    289            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x....             LDR.N    R0,??DataTable13
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0840             LSRS     R0,R0,#+1
   \   0000000A   0x0040             LSLS     R0,R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable13
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    290              SPIx_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
   \   00000012   0x20B9             MOVS     R0,#+185
   \   00000014   0x.... 0x....      BL       SPIx_ReadWriteByte
    291          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000018   0x....             LDR.N    R0,??DataTable13
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable13
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x6008             STR      R0,[R1, #+0]
    292              delay_ms(1);                               //等待TPD  
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       delay_ms
    293          }   
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    294          //唤醒

   \                                 In section .text, align 2, keep-with-next
    295          void SPI_Flash_WAKEUP(void)   
    296          {  
   \                     SPI_Flash_WAKEUP:
   \   00000000   0xB580             PUSH     {R7,LR}
    297            	SPI_FLASH_CS_LOW();                            //使能器件   
   \   00000002   0x....             LDR.N    R0,??DataTable13
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0840             LSRS     R0,R0,#+1
   \   0000000A   0x0040             LSLS     R0,R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable13
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6008             STR      R0,[R1, #+0]
    298              SPIx_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
   \   00000012   0x20AB             MOVS     R0,#+171
   \   00000014   0x.... 0x....      BL       SPIx_ReadWriteByte
    299          	SPI_FLASH_CS_HIGH();                            //取消片选     	      
   \   00000018   0x....             LDR.N    R0,??DataTable13
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable13
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x6008             STR      R0,[R1, #+0]
    300              delay_ms(1);                               //等待TRES1
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       delay_ms
    301          }   
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    302          
    303          
    304          //使用SysTick的普通计数模式对延迟进行管理
    305          //包括delay_us,delay_ms
    306          //2010/5/27

   \                                 In section .bss, align 4
    307          static unsigned int TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4
    308          
    309          
    310           /**
    311            * @brief  Inserts a delay time.
    312            * @param nTime: specifies the delay time length, in milliseconds.
    313            * @retval : None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void delay_ms(unsigned int nTime)
    316          { 
    317           while(--nTime);
   \                     delay_ms:
   \                     ??delay_ms_0:
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD1FC             BNE.N    ??delay_ms_0
    318          
    319           
    320          }
   \   00000006   0x4770             BX       LR               ;; return
    321          
    322          /**
    323            * @brief  Decrements the TimingDelay variable.
    324            * @param  None
    325            * @retval : None
    326            */
    327          
    328          
    329          

   \                                 In section .text, align 2, keep-with-next
    330          void TimingDelay_Decrement(void)
    331          {
    332            if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement:
   \   00000000   0x....             LDR.N    R0,??DataTable13_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??TimingDelay_Decrement_0
    333            { 
    334              TimingDelay--;
   \   00000008   0x....             LDR.N    R0,??DataTable13_2
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable13_2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    335            }
    336          }
   \                     ??TimingDelay_Decrement_0:
   \   00000012   0x4770             BX       LR               ;; return
    337          
    338          
    339          
    340          
    341          
    342           /**********************************初始化缓冲区为0x0或者0xFF**********************************/ 
    343           

   \                                 In section .text, align 2, keep-with-next
    344          void Init_Buffer (unsigned char *P,unsigned int Count,unsigned char Type) 
    345          
    346          {
   \                     Init_Buffer:
   \   00000000   0xB410             PUSH     {R4}
    347            unsigned int i;
    348            
    349             if(Type==0)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD108             BNE.N    ??Init_Buffer_0
    350             {
    351             
    352               for(i=0;i<Count;i++)*P++=0x0;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x0023             MOVS     R3,R4
   \                     ??Init_Buffer_1:
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD20D             BCS.N    ??Init_Buffer_2
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0x7004             STRB     R4,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0xE7F8             B.N      ??Init_Buffer_1
    353             
    354             }
    355             else
    356             {
    357               for(i=0;i<Count;i++)*P++=0xFF;
   \                     ??Init_Buffer_0:
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x0023             MOVS     R3,R4
   \                     ??Init_Buffer_3:
   \   0000001E   0x428B             CMP      R3,R1
   \   00000020   0xD204             BCS.N    ??Init_Buffer_2
   \   00000022   0x24FF             MOVS     R4,#+255
   \   00000024   0x7004             STRB     R4,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \   0000002A   0xE7F8             B.N      ??Init_Buffer_3
    358          
    359             }
    360          
    361          }
   \                     ??Init_Buffer_2:
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR               ;; return
    362          
    363          
    364          
    365          
    366          /**************************************************************************************
    367            函数功能：内存拷贝函数
    368          
    369          **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    370          void Copy_Mem (unsigned char *P1, const unsigned char *P2,unsigned int Count)
    371          {
   \                     Copy_Mem:
   \   00000000   0xB410             PUSH     {R4}
    372             
    373             unsigned int i ;
    374             for(i=0;i<Count;i++)*P1++=*P2++;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x0023             MOVS     R3,R4
   \                     ??Copy_Mem_0:
   \   00000006   0x4293             CMP      R3,R2
   \   00000008   0xD205             BCS.N    ??Copy_Mem_1
   \   0000000A   0x780C             LDRB     R4,[R1, #+0]
   \   0000000C   0x7004             STRB     R4,[R0, #+0]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \   00000014   0xE7F7             B.N      ??Copy_Mem_0
    375          
    376            
    377          }
   \                     ??Copy_Mem_1:
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    378          
    379          
    380          /**************************************************************************************
    381            函数功能：内存拷贝函数
    382          
    383          **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    384          void Copy_Char (unsigned char *P1, unsigned char *P2,unsigned int Count)
    385          {
   \                     Copy_Char:
   \   00000000   0xB410             PUSH     {R4}
    386             
    387             unsigned int i ;
    388             for(i=0;i<Count;i++)*P1++=*P2++;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x0023             MOVS     R3,R4
   \                     ??Copy_Char_0:
   \   00000006   0x4293             CMP      R3,R2
   \   00000008   0xD205             BCS.N    ??Copy_Char_1
   \   0000000A   0x780C             LDRB     R4,[R1, #+0]
   \   0000000C   0x7004             STRB     R4,[R0, #+0]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \   00000014   0xE7F7             B.N      ??Copy_Char_0
    389          
    390            
    391          }
   \                     ??Copy_Char_1:
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    392          
    393          
    394          
    395          
    396          /**************************************************************************************
    397            函数功能：内存比较函数函数
    398            比较指针指向的两个缓冲区的数据是否一样
    399            一样返回值为：  0
    400            不一样返回值为：1
    401          
    402          ***************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    403          unsigned char Compare_Mem (unsigned char *P1,unsigned char *P2,unsigned int Count)
    404          {
   \                     Compare_Mem:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    405             
    406             unsigned int i ;
    407             
    408             for(i=0;i<Count;i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
   \                     ??Compare_Mem_0:
   \   00000008   0x4294             CMP      R4,R2
   \   0000000A   0xD209             BCS.N    ??Compare_Mem_1
    409             {
    410              
    411               if(*P1==*P2)
   \   0000000C   0x7818             LDRB     R0,[R3, #+0]
   \   0000000E   0x780D             LDRB     R5,[R1, #+0]
   \   00000010   0x42A8             CMP      R0,R5
   \   00000012   0xD103             BNE.N    ??Compare_Mem_2
    412               {
    413                 
    414                 P1++;
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
    415                 
    416                 P2++;
   \   00000016   0x1C49             ADDS     R1,R1,#+1
    417                 
    418               }
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \   0000001A   0xE7F5             B.N      ??Compare_Mem_0
    419               else
    420               {
    421                 return 1;
   \                     ??Compare_Mem_2:
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B.N      ??Compare_Mem_3
    422                      
    423               }
    424               
    425             };
    426              return 0;
   \                     ??Compare_Mem_1:
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??Compare_Mem_3:
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
    427            
    428          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     GPIOx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     SPI_FLASH_BUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     TimingDelay
    429          
    430          
    431          
    432          
    433          
    434          
    435          
    436          
    437          
    438          
    439          
    440          
    441          
    442          
    443          
    444          
    445          
    446          
    447          
    448          
    449          
    450          
    451          
    452          
    453          
    454          
    455          
    456          
    457          
    458          
    459          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  Compare_Mem
        4  Copy_Char
        4  Copy_Mem
        4  Init_Buffer
        8  SPI_FLASH_Write_Disable
              8 -> SPIx_ReadWriteByte
        8  SPI_FLASH_Write_Enable
              8 -> SPIx_ReadWriteByte
        8  SPI_FLASH_Write_SR
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_Erase_Chip
              8 -> SPI_FLASH_Write_Enable
              8 -> SPI_Flash_Wait_Busy
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_Erase_Sector
              8 -> SPI_FLASH_Write_Enable
              8 -> SPI_Flash_Wait_Busy
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_PowerDown
              8 -> SPIx_ReadWriteByte
              8 -> delay_ms
       24  SPI_Flash_Read
             24 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadDeviceID
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadID
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_ReadSR
              8 -> SPIx_ReadWriteByte
        8  SPI_Flash_WAKEUP
              8 -> SPIx_ReadWriteByte
              8 -> delay_ms
        8  SPI_Flash_Wait_Busy
              8 -> SPI_Flash_ReadSR
       32  SPI_Flash_Write
             32 -> SPI_Flash_Erase_Sector
             32 -> SPI_Flash_Read
             32 -> SPI_Flash_Write_NoCheck
       24  SPI_Flash_Write_NoCheck
             24 -> SPI_Flash_Write_Page
       24  SPI_Flash_Write_Page
             24 -> SPI_FLASH_Write_Enable
             24 -> SPI_Flash_Wait_Busy
             24 -> SPIx_ReadWriteByte
       16  SPIx_ReadWriteByte
             16 -> SPI_Master_WriteRead
        0  TimingDelay_Decrement
        0  delay_ms


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
      38  Compare_Mem
      26  Copy_Char
      26  Copy_Mem
      48  Init_Buffer
    4096  SPI_FLASH_BUF
      50  SPI_FLASH_Write_Disable
      50  SPI_FLASH_Write_Enable
      60  SPI_FLASH_Write_SR
      54  SPI_Flash_Erase_Chip
      86  SPI_Flash_Erase_Sector
      48  SPI_Flash_PowerDown
      98  SPI_Flash_Read
      84  SPI_Flash_ReadDeviceID
      96  SPI_Flash_ReadID
      64  SPI_Flash_ReadSR
      48  SPI_Flash_WAKEUP
      12  SPI_Flash_Wait_Busy
     252  SPI_Flash_Write
      92  SPI_Flash_Write_NoCheck
     104  SPI_Flash_Write_Page
      26  SPIx_ReadWriteByte
       4  TimingDelay
      20  TimingDelay_Decrement
       8  delay_ms

 
 4 100 bytes in section .bss
 1 402 bytes in section .text
 
 1 402 bytes of CODE memory
 4 100 bytes of DATA memory

Errors: none
Warnings: none
